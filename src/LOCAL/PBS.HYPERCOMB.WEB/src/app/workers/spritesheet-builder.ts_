import { Injectable } from '@angular/core'
import { PixiDataServiceBase } from '../database/pixi-data-service-base'

@Injectable({
    providedIn: 'root',
})
export class SpritesheetBuilder extends PixiDataServiceBase {

    private worker!: Worker

    constructor() {
        super()
        try {
          //  this.worker = new Worker(new URL('./spritesheet.worker.ts', import.meta.url))
        } catch (error) {
            console.error('Failed to initialize worker:', error)
        }
    }

    public refresh = async () => {
        return
        // const cell = this.layout.tiles
        // if(!cell?.length) return // nothing to process here

        // // get the source tile hive-id.
        // const activeHive = this.state.activeHive()!
        // if ( await Assets.get(activeHive)) return

        // const { width, height } = this.settings

        // const spriteUrls: string[] = []
        // const positions: { x: number y: number }[] = []

        // const SPRITES_PER_ROW = 10

        // for (let i = 0 i < cell.length i++) {
        //     const cell = cell[i]


        //     // Extract tile as canvas and create Blob URL
        //     const canvas = <any>this.app.renderer.extract.canvas(tile)
        //     const blobUrl = await this.canvasToBlobUrl(canvas)
        //     spriteUrls.push(blobUrl)

        //     // Calculate position on the spritesheet grid
        //     const x = (i % SPRITES_PER_ROW) * width
        //     const y = Math.floor(i / SPRITES_PER_ROW) * height
        //     positions.push({ x, y })

        //     // Update tile data with sprite positions
        //     data.SpriteX = x
        //     data.SpriteY = y
        // }

        // // Send URLs and positions to the worker
        // return new Promise((resolve, reject) => {
        //     this.worker.onmessage = async (event) => {

        //         const { url: spritesheetURL } = event.data // Assuming worker returns { url: spritesheetURL }
        //         const tileDataList: Cell[] = []

        //         // Fetch the spritesheet URL to get a Blob
        //         const response = await fetch(spritesheetURL)
        //         const blob = await response.blob()
        //         const blobURL = URL.createObjectURL(blob)

        //         console.log(`spritesheet created: ${blobURL}`)

        //         // update the cache
        //         for (const cell of this.layout.tiles) {
        //             cell.SpritesheetBlob = blob
        //             tileDataList.push(cell)
        //         }

        //         // save so tiles can use spritesheet
        //         await this.tile_actions.bulkPut(tileDataList)

        //         const hiveId = this.state.activeHiveId!

        //         // Assets.add(hiveId, blobURL)

        //         resolve(spritesheetURL)
        //     }

        //     this.worker.onerror = (error) => {
        //         console.error('Worker error:', error)
        //         reject(error)
        //     }

        //     // Validate width and height before posting to the worker
        //     if (!Number.isFinite(width) || width <= 0 || !Number.isFinite(height) || height <= 0) {
        //         /// console.warn("Invalid dimensions for OffscreenCanvas:")
        //         return // Abort if dimensions are invalid
        //     }

        //     // Post the sprite data to the worker
        //     this.worker.postMessage({ spriteUrls, positions, width, height })
        // })
    }

    // Helper function to convert a canvas to a Blob URL
    private async canvasToBlobUrl(canvas: HTMLCanvasElement): Promise<string> {
        return new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
                if (blob) {
                    const url = URL.createObjectURL(blob)
                    resolve(url)
                } else {
                    reject(new Error('Failed to create Blob from canvas'))
                }
            }, 'image/png')
        })
    }

}


